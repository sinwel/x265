diff --git a/source/hardwareC/RkIntraPred.cpp b/source/hardwareC/RkIntraPred.cpp
index 71aa306..dd805ff 100644
--- a/source/hardwareC/RkIntraPred.cpp
+++ b/source/hardwareC/RkIntraPred.cpp
@@ -2010,6 +2010,7 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 {
 #define OUTPUT_4X4_DATA 1
 #define OUTPUT_8X8_DATA 1
+#define OUTPUT_16X16_DATA	1
 	uint8_t* fenc 	= pInterface_Intra->fenc;
 	int32_t width 	= pInterface_Intra->size;
 	int32_t height	= pInterface_Intra->size;
@@ -2194,6 +2195,79 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 16) && (cur_depth == 2)) // 16x16 CU
+		{
+			// print CU valid flag.`
+			uint8_t ValidIdx16x16[] = { 15, 13, 11, 9, 8, 6, 4, 2, 0 };// reverse
+			for ( uint8_t  i = 0 ; i < 9 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_REF_CU_VALID],"%d",
+					pInterface_Intra->bNeighborFlags[ValidIdx16x16[i]] == true ? 1 : 0);			    
+
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_REF_CU_VALID],"\n");
+			for ( uint16_t  i = 0 ; i < 16*16 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_LU],"%02x",fenc[256 - i]);			    
+				if ( (i + 1)%16 == 0 )
+				{
+					FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_LU],"\n");			    
+				}
+			}
+
+			//INTRA_16_TU_CABAC_BITS
+			uint64_t tu_cabac_bits[3];
+			uint32_t zscan = g_rk_raster2zscan_depth_4[cur_x_in_cu/4 + cur_y_in_cu*4];
+			tu_cabac_bits[0] = g_est_bit_tu_luma_NoCbf[1][cur_depth][zscan];
+			tu_cabac_bits[1] = g_est_bit_tu_cb_NoCbf[1][cur_depth][zscan];
+			tu_cabac_bits[2] = g_est_bit_tu_cr_NoCbf[1][cur_depth][zscan];
+
+			for (uint8_t i = 0; i < 3; i++)
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_TU_CABAC_BITS],"%08llx",tu_cabac_bits[i]);
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_TU_CABAC_BITS],"\n");
+
+			//INTRA_8_PU_PRED_MODE_BITS
+			uint64_t pu_pred_mode_bits[3];
+			pu_pred_mode_bits[0] = g_intra_est_bit_luma_pred_mode[cur_depth][zscan + 0];
+			pu_pred_mode_bits[1] = g_intra_est_bit_chroma_pred_mode[cur_depth][zscan + 0];
+			pu_pred_mode_bits[2] = g_intra_est_bit_chroma_pred_mode[cur_depth][zscan + 0];
+
+			for (uint8_t i = 0; i < 3; i++)
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_PU_PRED_MODE_BITS],"%08llx",pu_pred_mode_bits[i]);
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_PU_PRED_MODE_BITS],"\n");
+
+			//INTRA_8_TU_CBF_BITS
+			uint64_t tu_cbf_bits[3];
+			tu_cbf_bits[0] = g_intra_est_bit_cbf[0][cur_depth][zscan + 0];
+			tu_cbf_bits[1] = g_intra_est_bit_cbf[1][cur_depth][zscan + 0];
+			tu_cbf_bits[2] = g_intra_est_bit_cbf[2][cur_depth][zscan + 0];
+
+			for (uint8_t i = 0; i < 3; i++)
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_TU_CBF_BITS],"%06llx",tu_cbf_bits[i]);
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_TU_CBF_BITS],"\n");
+
+			//INTRA_8_PU_PART_MODE_BITS
+			uint64_t pu_part_mode_bits[3];
+			pu_part_mode_bits[0] = g_intra_est_bit_part_mode[cur_depth][zscan + 0];
+			pu_part_mode_bits[1] = g_intra_est_bit_part_mode[cur_depth][zscan + 0];
+			pu_part_mode_bits[2] = g_intra_est_bit_part_mode[cur_depth][zscan + 0];
+
+			for (uint8_t i = 0; i < 3; i++)
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_PU_PART_MODE_BITS],"%06llx",pu_part_mode_bits[i]);
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_PU_PART_MODE_BITS],"\n");
+			
+		}
+		
+	#endif
 
 	
 		/* step 1 */
@@ -2247,6 +2321,19 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		}
 		
 	#endif
+	#if OUTPUT_16X16_DATA
+
+		if((width == 16) && (cur_depth == 2)) // 16X16 CU
+		{
+			for ( uint8_t  i = 0 ; i < 65 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_LU],"%02x",LineBuf[64 - i]);			    
+
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_LU],"\n");
+		}
+		
+	#endif
 
 		// step 2 //
 
@@ -2276,7 +2363,20 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		FPRINT(fp_intra_8x8[INTRA_8_REF_PIXEL_CU_LU_FILTER],"\n");			    
 	}
 #endif
+
+#if OUTPUT_16X16_DATA
+	if((width == 16) && (cur_depth == 2)) // 16x16 CU
+	{
+		// INTRA_16_REF_PIXEL_CU_LU_FILTER
+		for ( uint16_t  i = 0 ; i < 2*width + 1 ; i++ )
+			FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_LU_FILTER],"%02x",refAboveFlt[3*width - 1 - i]);			    
+		for ( uint16_t  i = 0 ; i < 2*width     ; i++ )
+			FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_LU_FILTER],"%02x",refLeftFlt[i + width]);	
 		
+		FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_LU_FILTER],"\n");			    
+	}
+#endif
+
 #ifdef INTRA_RESULT_STORE_FILE
 		// width - 1 是为了在做pred扩展用的
 		StoreSmoothing(g_fp_result_rk,
@@ -2482,6 +2582,42 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		}
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 16) && (cur_depth == 2)) // LEVEL 2
+		{
+			// INTRA_16_SAD
+			for ( uint8_t  i = 0 ; i < 34 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_SAD],"%d %04x, ",i, costSad[i]);			    
+			}
+			
+			FPRINT(fp_intra_16x16[INTRA_16_SAD],"%d %04x",34,costSad[34]);	
+			
+			FPRINT(fp_intra_16x16[INTRA_16_SAD],"\n");	
+
+
+			// INTRA_16_TU_COST_BITS
+			  
+			for ( uint8_t  i = 0 ; i < 34 ; i+=2 )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_TU_COST_BITS],"%d %04x, ",i, costTotal[i]);			    
+			}
+			
+			FPRINT(fp_intra_16x16[INTRA_16_TU_COST_BITS],"%d %04x",34,costTotal[34]);	
+			
+			FPRINT(fp_intra_16x16[INTRA_16_TU_COST_BITS],"\n");				
+
+			// INTRA_16_CABAC_MODE_BIT	  
+			for ( uint8_t  i = 34 ; i > 0 ; i-- )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_CABAC_MODE_BIT],"%02x",bits_luma_dir[i]);			    
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_CABAC_MODE_BIT],"%02x",bits_luma_dir[0]);	
+			FPRINT(fp_intra_16x16[INTRA_16_CABAC_MODE_BIT],"\n");	
+			
+		}
+	#endif
+
 		// step 5 //
 		// get minnum costSad + lambad*bits,decide the dirMode
 		uint32_t index[35];
@@ -2532,6 +2668,17 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		}
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		
+		if((width == 16) && (cur_depth == 2)) // LEVEL 2
+		{
+			FPRINT(fp_intra_16x16[INTRA_16_BEST_MODE],"%02x\n",bestMode);	// y
+			FPRINT(fp_intra_16x16[INTRA_16_BEST_MODE],"%02x\n",bestMode);	// cb
+			FPRINT(fp_intra_16x16[INTRA_16_BEST_MODE],"%02x\n",bestMode);	// cr
+		}
+	#endif
+
+
 		pInterface_Intra->DirMode = (uint8_t)bestMode;
 
 		// step 6 //
@@ -2590,6 +2737,27 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 16) && (cur_depth == 2))  
+		{
+			// y
+			for ( uint16_t  i = 0 ; i < (width*width) ; i++ )
+			{
+				{
+					FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"%04x",(uint16_t)rk_residual[RK_COMPENT][(width*width - 1) - i]);	
+					FPRINT(fp_intra_16x16[INTRA_16_PRED],"%02x",rk_pred[RK_COMPENT][(width*width - 1) - i]);			    
+					if ( (i + 1)%16 == 0 ) // 16 一行
+					{
+					    FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"\n");
+						FPRINT(fp_intra_16x16[INTRA_16_PRED],"\n");
+					}
+				}
+			}
+		}
+		
+	#endif
+
+
 	#if OUTPUT_4X4_DATA
 		if((width == 4) && (cur_depth == 4)) // LEVEL 3
 		{
@@ -2639,6 +2807,21 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 8) && (cur_depth == 2)) // 16x16 CU, chroma size is half of CU.
+		{
+			for ( uint16_t  i = 0 ; i < width*width ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_CB],"%02x",fenc[width*width - 1 - i]);	
+				if ( (i + 1)%16 == 0 )
+				{
+					FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_CB],"\n");			
+				}
+			}
+		}
+		
+	#endif
+
 
 		// step 1 //
 		// fill
@@ -2690,6 +2873,20 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+
+		if((width == 8) && (cur_depth == 2)) // 16x16 CU, chroma size is half of CU.
+		{
+			for ( uint8_t  i = 0 ; i < 33 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_CB],"%02x",LineBuf[32 - i]);			    
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_CB],"\n");
+		}
+		
+	#endif
+
+
 		// chroma 不需要 smoothing操作
 		// 需要将 lineBuf 变为 refLeft 和 refAbove
 		uint8_t 	refLeft[33 + 16 - 1];
@@ -2754,6 +2951,25 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 8) && (cur_depth == 2)) // 16x16 CU, chroma size is half of CU.
+		{
+			// cb
+			for ( uint16_t  i = 0 ; i < (width*width) ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"%04x",(uint16_t)rk_residualCb[RK_COMPENT][(width*width - 1) - i]);			    
+				FPRINT(fp_intra_16x16[INTRA_16_PRED],"%02x",rk_predCb[RK_COMPENT][(width*width - 1) - i]);			    
+				if ( (i + 1)%16 == 0 ) // 16 一行
+				{
+				    FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"\n");
+					FPRINT(fp_intra_16x16[INTRA_16_PRED],"\n");
+				}
+			}
+		}
+		
+	#endif
+
+
 	#if OUTPUT_4X4_DATA
 		if((width == 4) && (cur_depth == 4)) // LEVEL 3
 		{
@@ -2873,6 +3089,31 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 			FPRINT(fp_intra_8x8[INTRA_8_REF_PIXEL_CU_CR],"\n");
 		}
 	#endif 
+
+	#if OUTPUT_16X16_DATA
+
+		if((width == 8) && (cur_depth == 2)) // 16x16 CU, chroma size is half of CU.
+		{
+			for ( uint16_t  i = 0 ; i < width*width ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_CR],"%02x",fenc[width*width - 1 - i]);			    
+				if ( (i + 1)%8 == 0 )
+				{
+					FPRINT(fp_intra_16x16[INTRA_16_ORI_PIXEL_CU_CB],"\n");			
+				}
+			}
+
+
+			for ( uint8_t  i = 0 ; i < 33 ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_CR],"%02x",LineBuf[32 - i]);			    
+			}
+			FPRINT(fp_intra_16x16[INTRA_16_REF_PIXEL_CU_CR],"\n");
+		}
+
+
+	#endif 
+
 		// chroma 不需要 smoothing操作
 		// 需要将 lineBuf 变为 refLeft 和 refAbove
 		uint8_t 	refLeft[33 + 16 - 1];
@@ -2940,6 +3181,25 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		
 	#endif
 
+	#if OUTPUT_16X16_DATA
+		if((width == 8) && (cur_depth == 2)) // 16x16 CU, chroma size is half of CU.
+		{
+			// cr
+			for ( uint16_t  i = 0 ; i < (width*width) ; i++ )
+			{
+				FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"%04x",(uint16_t)rk_residualCr[RK_COMPENT][(width*width - 1) - i]);			    
+				FPRINT(fp_intra_16x16[INTRA_16_PRED],"%02x",rk_predCr[RK_COMPENT][(width*width - 1) - i]);			    
+				if ( (i + 1)%16 == 0 ) // 16 一行
+				{
+				    FPRINT(fp_intra_16x16[INTRA_16_RESI_BEFORE],"\n");
+					FPRINT(fp_intra_16x16[INTRA_16_PRED],"\n");
+				}
+			}
+		}
+		
+	#endif
+
+
 	
 	#if OUTPUT_4X4_DATA
 		if((width == 4) && (cur_depth == 4)) // LEVEL 3
@@ -2974,6 +3234,8 @@ void Rk_IntraPred::Intra_Proc(INTERFACE_INTRA* pInterface_Intra,
 		RK_HEVC_PRINT("%s Error case Happen.\n",__FUNCTION__);
 	}
 #undef OUTPUT_4X4_DATA
+#undef OUTPUT_8X8_DATA	
+#undef OUTPUT_16X16_DATA
 }
 
 
diff --git a/source/hardwareC/RkIntraPred.h b/source/hardwareC/RkIntraPred.h
index 260918f..632f8cd 100644
--- a/source/hardwareC/RkIntraPred.h
+++ b/source/hardwareC/RkIntraPred.h
@@ -135,6 +135,39 @@ typedef enum Intra8HardwareFile
     INTRA_8_FILE_NUM
 } Intra8HardwareFile;
 
+typedef enum Intra16HardwareFile
+{
+    INTRA_16_SAD               , //按照35个一行 y 的顺序进行打印 0 sad[0], 1 sad[1], 2 sad[2], 3 sad[3], ... 34 sad[34]
+    INTRA_16_CABAC_MODE_BIT    , //按照35个一行 y 的顺序进行打印 [bit34][bit33]...[bit2][bit1][bit0] 
+    INTRA_16_ORI_PIXEL_CU_LU   , // 16x16 CU 按照16 x 16个像素一行的顺序打印，打印顺序p[63]p[62]p[61]...p[1]p[0]
+    INTRA_16_ORI_PIXEL_CU_CB   , // 16x16 CU 按照8 x 8个像素一行的顺序打印，打印顺序p[15]p[14]p[13]...p[1]p[0]
+    INTRA_16_ORI_PIXEL_CU_CR   , // 16x16 CU 按照8 x 8个像素一行的顺序打印，打印顺序p[15]p[14]p[13]...p[1]p[0]
+    INTRA_16_REF_PIXEL_CU_LU   , // 16x16 CU的ref pixel lu像素 65个像素一行 打印顺序p[64]p[63]p[62]...p[1]p[0]
+    INTRA_16_REF_PIXEL_CU_CB   , // 16x16 CU的ref pixel cb像素 33个像素一行 打印顺序p[32]p[31]p[30]...p[1]p[0]
+    INTRA_16_REF_PIXEL_CU_CR   , // 16x16 CU的ref pixel cr像素 33个像素一行 打印顺序p[32]p[31]p[30]...p[1]p[0]
+    INTRA_16_REF_CU_VALID      , // 16x16 CU的ref cu valid信号 按照9bit一行的顺序打印[8][7][6][5][4][3][2][1][0]
+    INTRA_16_RESI_BEFORE       , // 预测出来残差像素 按照16个像素一行的顺序打印，每个像素位宽为16bit，打印顺序p[15]p[14]p[13]...p[1]p[0];
+								 //	cb两行拼成1行	cr两行拼成1行 	按照y cb cr的顺序打印
+    INTRA_16_RESI_AFTER        , // 经过IT之后的残差像素 按照16个像素一行的顺序打印，每个像素位宽为16bit，打印顺序p[15]p[14]p[13]...p[1]p[0];
+								 // cb两行拼成1行 	cr两行拼成1行 	按照y cb cr的顺序打印
+    INTRA_16_PRED              , // 经过IT之后的残差像素 按照16个像素一行的顺序打印，每个像素位宽为8bit，打印顺序p[15]p[14]p[13]...p[1]p[0];
+								 // cb两行拼成1行 	cr两行拼成1行 	按照y cb cr的顺序打印
+    INTRA_16_RECON             , // 经过IT之后的残差像素 按照16个像素一行的顺序打印，每个像素位宽为8bit，打印顺序p[15]p[14]p[13]...p[1]p[0];
+								 // cb两行拼成1行 	cr两行拼成1行 	按照y cb cr的顺序打印
+    INTRA_16_BEST_MODE         , // 按照8bit一行进行打印;按照y cb cr的顺序打印 
+    INTRA_16_TU_CABAC_BITS   	, //按照一个tu 残差 24 bit一行的顺序进行打印;按照y cb cr 的顺序打印 
+    INTRA_16_PU_PRED_MODE_BITS   , //按照 32 bit一行的数据进行打印,按照y cb cr的顺序进行打印
+    INTRA_16_CU_TOTAL_BITS       , //按照24bit一行的顺序进行打印
+    INTRA_16_CU_TOTAL_DISTORTION , //按照32bit一行的顺序进行打印
+    INTRA_16_CU_TOTAL_COST       , //按照32bit一行的顺序进行打印
+    INTRA_16_TU_COST_BITS		, //按照一个Y分量的TU的(sad + sad_lambda * bit)打印;顺序0 cost[0], 1 cost[1], 2 cost[2], 4 cost[4], ... 34 cost[34];cost按32bit打印
+    INTRA_16_TU_CBF_BITS         , //按照 24 bit打印 ，y cb cr 的顺序打印 一个TU 一行
+    INTRA_16_PU_PART_MODE_BITS	, //按照 24 bit一行的顺序进行打印,一个PU一行
+    INTRA_16_REF_PIXEL_CU_LU_FILTER  ,//16x16 CU的ref pixel lu像素 经过滤波后的lu ref像素 65个像素一行 打印顺序p[64]p[63]p[62]...p[1]p[0]
+
+    INTRA_16_FILE_NUM
+} Intra16HardwareFile;
+
 class Rk_IntraPred
 {
 public:
@@ -144,6 +177,7 @@ public:
     FILE *rk_logIntraPred[20];
     FILE* fp_intra_4x4[INTRA_4_FILE_NUM];
     FILE* fp_intra_8x8[INTRA_8_FILE_NUM];
+    FILE* fp_intra_16x16[INTRA_16_FILE_NUM];
 
     int     num_4x4fp;
     int     num_8x8fp;
diff --git a/source/hardwareC/hardwareC.cpp b/source/hardwareC/hardwareC.cpp
index e8c52af..8828584 100644
--- a/source/hardwareC/hardwareC.cpp
+++ b/source/hardwareC/hardwareC.cpp
@@ -251,14 +251,30 @@ void hardwareC::ConfigFiles(FILE *fp)
 				}
 				
 				strcpy( namebuff, CFG_FILE);
-				strcat( namebuff, cmdbuff);
+				
 				
 				/*open output file */
-				if ( num >= INTRA_4_FILE_NUM)
+				if ( num >= INTRA_4_FILE_NUM + INTRA_8_FILE_NUM)
+				{
+					strcat( namebuff, "/16x16/");
+					strcat( namebuff, cmdbuff);
+					ctu_calc.cu_level_calc[2].m_rkIntraPred->fp_intra_16x16[num - INTRA_4_FILE_NUM - INTRA_8_FILE_NUM] = fopen(namebuff, "w");
+					RK_HEVC_PRINT("the %d file name is: %s \n",num - INTRA_4_FILE_NUM - INTRA_8_FILE_NUM,namebuff);
+				}
+				else if ( num >= INTRA_4_FILE_NUM)
+				{
+					strcat( namebuff, "/8x8/");
+					strcat( namebuff, cmdbuff);
 					ctu_calc.cu_level_calc[3].m_rkIntraPred->fp_intra_8x8[num - INTRA_4_FILE_NUM] = fopen(namebuff, "w");
+					RK_HEVC_PRINT("the %d file name is: %s \n",num - INTRA_4_FILE_NUM, namebuff);
+				}
 				else if ( num < INTRA_4_FILE_NUM)
+				{
+					strcat( namebuff, "/4x4/");
+					strcat( namebuff, cmdbuff);
 					ctu_calc.cu_level_calc[3].m_rkIntraPred->fp_intra_4x4[num] = fopen(namebuff, "w");
-
+					RK_HEVC_PRINT("the %d file name is: %s \n",num ,namebuff);
+				}
 				num++;
 
                 break;
diff --git a/source/hardwareC/level_mode_calc.cpp b/source/hardwareC/level_mode_calc.cpp
index 28d6fe0..062e130 100644
--- a/source/hardwareC/level_mode_calc.cpp
+++ b/source/hardwareC/level_mode_calc.cpp
@@ -954,7 +954,8 @@ void CU_LEVEL_CALC::intra_proc()
 	uint32_t totalBits4x4 = 0;
 #endif
 
-#define OUT_8X8	1
+#define OUT_8X8		1
+#define OUT_16X16	1
 	//=====================================================================================//
     /* -------------- Y ----------------*/
     inf_recon.size = m_size;
@@ -1047,6 +1048,23 @@ void CU_LEVEL_CALC::intra_proc()
 		FPRINT(m_rkIntraPred->fp_intra_8x8[INTRA_8_RECON],"\n");	
 	}
 #endif
+#if OUT_16X16
+	// Y
+	if (m_size == 16)
+	{
+		for ( uint16_t  j = 0 ; j < m_size*m_size ; j++ )
+		{
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"%04x",(uint16_t)inf_recon.resi[m_size*m_size - 1 - j]);			    
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"%02x",inf_recon.Recon[m_size*m_size - 1  - j]);			    
+			if ( (j+1) % 16 == 0 )
+			{
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"\n");			    
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"\n");	
+			}
+		}
+	}
+#endif
+
     //CABAC();
 
     // store [ Y output] to [inf_intra_proc]
@@ -1119,6 +1137,25 @@ void CU_LEVEL_CALC::intra_proc()
 		FPRINT(m_rkIntraPred->fp_intra_8x8[INTRA_8_RECON],"\n");	
 	}
 #endif
+
+#if OUT_16X16
+	// cb
+	if (m_size == 16)
+	{
+		for ( uint16_t  j = 0 ; j < m_size*m_size/4 ; j++ )
+		{
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"%04x",(uint16_t)inf_recon.resi[m_size*m_size/4 - 1 - j]);			    
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"%02x",inf_recon.Recon[m_size*m_size/4 - 1  - j]);			    
+			if ( (j+1) % 16 == 0 )
+			{
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"\n");			    
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"\n");	
+			}
+		}
+	}
+#endif
+
+
     // store [ U output] to [inf_intra_proc]
     inf_intra_proc.ReconU 	= inf_recon.Recon;
     inf_intra_proc.ResiU 	= inf_recon.resi;
@@ -1205,6 +1242,23 @@ void CU_LEVEL_CALC::intra_proc()
 	}
 #endif
 
+#if OUT_16X16
+	// cR
+	if (m_size == 16)
+	{
+		for ( uint16_t  j = 0 ; j < m_size*m_size/4 ; j++ )
+		{
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"%04x",(uint16_t)inf_recon.resi[m_size*m_size/4 - 1 - j]);			    
+			FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"%02x",inf_recon.Recon[m_size*m_size/4 - 1  - j]);			    
+			if ( (j+1) % 16 == 0 )
+			{
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RESI_AFTER],"\n");			    
+				FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_RECON],"\n");	
+			}
+		}
+	}
+#endif
+
 
     //CABAC();
 	// store [ V output] to [inf_intra_proc]
@@ -1247,6 +1301,19 @@ void CU_LEVEL_CALC::intra_proc()
 #endif
 
 	
+#if OUT_16X16
+	if (m_size == 16)
+	{
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_BITS],"%08x",totalBits8x8);	
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_BITS],"\n");	
+
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_DISTORTION],"%08x",inf_intra_proc.Distortion);	
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_DISTORTION],"\n");	
+
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_COST],"%08x",inf_intra_proc.totalCost);			    
+		FPRINT(m_rkIntraPred->fp_intra_16x16[INTRA_16_CU_TOTAL_COST],"\n");			    
+	}
+#endif
 
 
 
@@ -1561,7 +1628,7 @@ void CU_LEVEL_CALC::intra_proc()
 	#endif
     }
 #undef OUT_8X8	
-	
+#undef OUT_16X16	
 }
 
 
